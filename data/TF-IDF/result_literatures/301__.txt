Decentralized  ledger-based  cryptocurrencies  like  Bitcoin  ( Nakamoto, 2008 ) present a way to construct payment sys tems  without  trusted  banks.  After  Bitcoin,  many  digital  currencies try to improve it in different aspects, including  functionality ( Eyal et al., 2016; Garay et al., 2015; King and  Nadal, 2012; Kroll et al., 2013 ), consensus scheme ( King and  Nadal, 2012; Sompolinsky and Zohar, 2013 ), scalability and  efficiency ( Eyal et al., 2016; Wood, 2014 ), and privacy ( Kosba  et al., 2016; Valenta and Rowan, 2015 ), etc. 

Privacy protection in ledger-based digital currencies has  attracted tremendous attention ( Bonneau et al., 2015 ). Bitcoin  has been thoroughly analyzed and its privacy is deemed frag ile ( Reid and Harrigan, 2013 ). Analyzing the transaction graph,  values and dates in the ledger possibly link Bitcoin addresses  with real world identities. Mixes are designed to break the linkability in Bitcoin system. A mix is a trusted party who  mixes coins from many users and gives different coins back  to them. However, coin mixing is time-consuming and cen tralized, so a mix is required to be trustworthy. Therefore,  decentralized mixes are constructed like TumbleBit ( Heilman  et al., 2016 ), CoinSwap ( Maxwell, 2013b ), CoinParty ( Ziegeldorf  et  al., 2015 ), CoinShuffle( Ruffing  et  al., 2014 )  and  CoinJoin  ( Maxwell, 2013a ), and altcoins such as Zerocoin ( Miers et al.,  2013 ), BlindCoin ( Valenta and Rowan, 2015 ), Mixcoin ( Bonneau  et al., 2014 ) and Pinocchio coin ( Danezis et al., 2013 ), etc. How ever, these  solutions  still  suffer  drawbacks:  1)  Insufficient  performance. Most of them require more than one round of  interactions between many parties. 2) Lack of functionality.  They allows “washing” coins from time to time, but fail to  hide everyday transactions. 

For  other  ledger-based  digital  currencies,  works  have  been  trying  to  solve  the  scalability  and  efficiency  issues.  Changing  the  blocksize  ( Andresen, 2014 )  straightforwardly  increases the scalability, while compromising efficiency by  higher  network  latency  and  longer  verification  time.  The  block  merging  proposed  in  MimbleWimble  ( Jedusor,  2016 )  requires a special structure for the blocks and transactions,  sacrificing a majority of the digital currency functionalities.  Currently, micropayment channel ( Poon and Dryja, 2016 ) is  the most promising solution to both scalability and efficiency  problems. Micropayment  channel  enables  Bitcoin  users  to  conduct payments securely off-chain, promising to support  billions of users. However, nobody has proposed to construct  a micropayment system on Zerocash.1 



We  develop  a  micropayment  scheme  over  Zerocash,  Z-Channel .  Z-Channel  allows  numerous  users  to  perform  high-frequency transactions off-chain in day-to-day routine,  conducting payments nearly instantly. Meanwhile, Z-Channel  is established and terminated with strong privacy guarantee.  To implement Z-Channel on Zerocash, we improve the Dis tributed Anonymous Payment (DAP) scheme of Zerocash and  + + propose a new scheme called DAP Plus (DAP   for short). DAP  enriches  DAP  with  multisignature  and  time  lock  features  needed by Z-Channel. We give the formal definition of the se +  scheme based on the original DAP scheme. We  curity of DAP  + prove that DAP scheme is secure under this definition. 

Moreover, we implement the zk-SNARK for the new NP  statement,  based  on  the  code  of  ZCash,2  and  instantiate  the Z-Channel protocol. We benchmark the zero-knowledge  proofs  and  the  procedures  in  Z-Channel  protocol.  In  our  experiment, a payment can be issued within 3 milliseconds,  which  is  significantly  faster  than  the  original  Zerocash  payment,  which  requires  several  minutes  for  generating  zero-knowledge proof, and dozens of minutes for ledger con firmation. Of course, Z-Channel still share some drawbacks of  Zerocash. For example, users have to store a public reference  string of several hundreds megabytes, and trusted third party  is required to generate the public reference string. 

Zerocash is constructed by overlaying a Decentralized Anony mous  Payment  (DAP)  scheme  over  Bitcoin  or  any  other  ledger-based cryptocurrencies, which we call the basecoin. 

DAP introduces a new kind of coin called shielded coin (by  contrast, we call the unspent outputs in basecoin transpar ent coins ), denoted by c   r, s ), where cm is an   a pk  , information-hiding  trapdoor  commitment,  ρ is  a  random  string for generating the unique serial number sn for this coin.  ρ together with the denomination v and shielded address a pk of  the owner are concealed in cm . r and s are the trapdoors used  in commitment. 

DAP  introduces  two  types  of  transactions  to  handle  shielded coins: A mint transaction tx Mint transforms transpar ent coins into a shielded coin, and a pour transaction tx Pour  conducts payments between shielded coins. tx Pour could also transform part of the input shielded coins back to transparent  coins. 


Our construction of Z-Channel relies on two functionalities:  Multisignature and time lock. However, they are not provided  by the original Zerocash scheme, i.e. DAP scheme. To solve  this issue, we present DAP Plus, which is an improvement  to the DAP scheme, with support to multisignature and time  lock features. 

The  naive  implementation  of  multisignature  scheme  in  Bitcoin, i.e. counting the number of signatures, reveals some  data which compromises the privacy if used in Zerocash. We  implement the multisignature feature in an alternative way,  namely  the  distributed  signature  generation  scheme  ( Gennaro  et al., 1999 ). Specifically, we require the scheme to support the  following operations: 

In this subsection, we present the improvements of DAP  compared to the original DAP scheme. For convenience, we  assume that the involved parties are Alice and Bob, and Alice  is trying to send a coin to Bob. 

Commit to a public key lock in the coin. In Zerocash, a  shielded coin c consists of a commitment cm and some secret  data necessary for opening cm . The commitment involves the  following data: The shielded address a pk owned by Bob, the denomination v and a random string  ρ (used for generating  +  , we  require  Alice  to  addition serial  number  sn ). In  DAP  ally commit a public key lock pklk into cm . pklk is a properly  encoded  public  key  of  some  public  signature  scheme. For  implementing multisignature functionality, we suggest that  it is a distributed signature generation scheme described in last  section, to enable multiple users to share a public key which  is indistinguishable from a public key generated by a single  user. For now we simply assume that Bob generates a pair of  keys locally and sends the public key pklk to Alice for her to  commit into cm . To fix the length of the committed data in cm  , Alice commits the hash of pklk   Hash ( pklk )   denoted by pkh  , instead of pklk . When Bob tries to spend this coin, he has  to append to the transaction a signature  σ which is verified  by pklk . We denote the data protected by this signature (for  example, the entire transaction, or a short fixed string) by a  function ToBeLocked ()   and leave it to be determined by the  , + application that builds on top of DAP 

To allow other parties to verify the signature, pklk should  be  disclosed  as  the  coin  is  spent.  The  anonymity  of  Bob  against Alice is thus compromised, since Alice would imme diately perceive when Bob spends the coin, by identifying pklk  published in the transaction. To solve this problem, we let  Bob commit pkh into a commitment pkcm   with his secret key  , a sk as trapdoor, and sends pkcm to Alice. Therefore, Alice does  not know either pklk or its hash pkh   but she is still able to  , commit pkh into cm in an indirect way, i.e. committing pkcm  into cm . We modify the zero-knowledge NP statement POUR  in Sasson et al. (2014) for the pour transaction so that Alice  only needs to prove that she knows pkcm for the new coins.  When Bob spends his coin, however, he has to prove that the  revealed pkh is correctly committed in the coins to spend,  with his knowledge of a sk . 

Commit a time lock in coin. Next, we commit a time lock  tlk into the coin. To avoid the clock synchronizing issue, we  use the block height as the clock. For simplicity, we denote  the height of the block containing a coin commitment cm  by BH ( cm ) . We then require that Alice appends a minimum  block height  MBH in the pour transaction. A transaction is  considered invalid if its MBH is larger than the height of the  block containing it, thus cannot get on the ledger until the  block height reaches MBH . For each input coin, Alice should  + prove that BH ( cm ) 

MBH in zero-knowledge.  There is, however, a tricky issue about BH ( cm )   since it is  , somehow independent from cm   i.e. there is no computational  , relationship between them. Therefore, it is hard to prove in  zero-knowledge that Alice has input the correct BH ( cm ) as a  secret input to the zk-SNARK prover. In the meantime, BH ( cm )  cannot be disclosed, as this would compromise the privacy of  Alice. 



We solve this issue by noting that Alice does not have to  + prove that BH ( cm )   MBH where  BH (?) is the block height of something that is guaranteed to  be later than cm on the ledger and safe to be disclosed. The  best candidate for this is the Merkle-tree root rt   which is used  , to prove the existence of the input coin commitment. Each  time when a new coin commitment is appended on a ledger,  the root is updated to a new one, thus there is a one-to-one  correspondence between the list of commitments and the  history of roots. We then naturally define the block height of a Merkle-root rt as that of the corresponding commitment  and denote it by BH ( rt ) . 

Logical  relationship  between  public  key  lock  and  time  lock. If a coin commits a public key lock pklk and time lock tlk  , we say the coin is locked by pklk with tlk blocks. If tlk is set to  the maximum time lock MTL   then we say the coin is locked  , by pklk forever. We denote a pair of public key commitment   and a pair of public key   tlk )    ( pkcm  and time lock by lock  , , = σ ) . We say unlock unlocks  lock and signature by unlock   ( pklk  , a lock if pklk is a correct opening of pkcm and the contained  signature is valid. 

We decide to take the “OR” relationship between the public  key lock and the time lock. That is to say, the transaction  is valid either when the time lock expires or a valid unlock  is provided. To say it in another way, a coin is locked by tlk  blocks unless overridden by the signature. 

We accomplish this by adding a overriding boolean flag ovd  as a public input to zk-SNARK, which is true if and only if a  valid unlock is appended in the transaction.

Note that this logic can be easily modified, without modi fying the NP statement POUR . For example, by always setting  ovd to false and requiring a valid unlock, the logic between  the locks then becomes “AND”. Similarly, always setting ovd  to true totally neglects the time lock. We will use a slightly  modified version of logic in Z-Channel, but for simplicity, we  only describe constructing with basic OR logic in this section. 


The Mint algorithm in Zerocash is invoked to generate a Mint  transaction which spends unspent output in basecoin and  outputs a coin commitment. MintPlus modifies the original  algorithm,  by  additionally  committing  a  public  key  com mitment pkcm and a time lock tlk . The other parts of the  algorithm  are  left  unmodified. The  details  of  the  MintPlus  algorithm are presented in Algorithm 1 . 

Pour algorithm. The PourPlus algorithm transfers values  from two input coins into two new coins, and optionally trans fer part of the input value back to the basecoin. Pouring allows  parties to subdivide coins, merge coins or transfer ownership.  PourPlus generates two coins and a pour transaction. 

The  inputs  to  the  PourPlus  algorithm  can  be  roughly  categorized into two groups. One group consists of the wit nesses for validating the input coins. Specifically, we define a  CoinWitness to be an assemble of the following information: 

VerifyPlus modifies the original Verify algorithm, by addition ally verifying the signatures of the public key locks if needed.  The public inputs to the zk-SNARK module are also changed  accordingly. The details of VerifyPlus algorithm are presented  in Algorithm 3 . 

The  ReceivePlus algorithm  scans the  ledger and outputs coins on the ledger belonging to a given  shielded address. 

ReceivePlus modifies the original Receive algorithm, by addi tionally checking that the public key commitment pkcm is  previously generated by CreatePKCM and never used before.  The  details  of  the  ReceivePlus  algorithm  are  presented  in  Algorithm 4 . 

The NP statement. Finally, we modify the NP statement  POUR  for  the  zk-SNARK  module  to  add  a  claim  that  the  public key lock pklk and the time locks tlk have been correctly  committed, and that the time locks are either expired or over ridden. Following is the detail of the modified NP statement  POUR for the zero-knowledge proof. 

In the  BAL experiment, interacts with one DAP Plus  scheme oracle and wins the game if the total value he can  spend or has spent is greater than the value he has minted  A or received. The balance requires that   wins with negligible  probability. 

The  following  theorem  claims  that  our  construction  of  DAP Plus scheme is complete and secure under the above  definitions. 


In the next subsections, we will discuss the two properties  of  our  construction  of  Z-Channel  based  on  the  following  assumption: Alice and Bob always have a secure communi cation channel established between them whenever needed.  Specifically, we require that the channel is secure against  eavesdropping and man-in-the-middle attacks. 


We  implement  the  distributed  signature  generation  scheme  with  EC-Schnorr  signature  ( Gennaro  et  al.,  1999 ).  We take SHA256 as the public key hash function Hash . We  compute pkcm with trapdoor a sk (which is 252-bit string in  ZCash), by taking the SHA256 compression of their concate  5) nation a sk   pkh prefixed by four zero-bits. The time lock is set  as a 64-bit integer. As in ZCash, we abandon the trapdoor  s and compute the coin commitment as the SHA256 of the  concatenation of all the coin data. 

Instantiation of Z-Channel. For the distributed generation  of Schnorr keys and signature, we take the following simple  procedures: 

For the consensus of secret seed, assume Alice and Bob  have a secure communication channel. Alice and Bob gener ate random 256-bit strings s and t ; Alice commits s to Bob, Bob  =  s 2)t.  sends t to Alice, and Alice sends s to Bob; the seed is seed 

We  construct  the  circuit  of  the  new  NP  statement  for  zk-SNARK based on the code of ZCash. Table 2 shows the  performance of the zero-knowledge proof procedures, in com parison with that of the original DAP scheme. The modifica + tions introduced in DAP   scheme slightly (around 0.1% to 8%)  increase the key sizes and the time consumption, as expected. 


In testing performance of a single Z-Channel, we run the  Z-Channel clients on localhost to minimize the effect of real  network latency, and simulate different network latencies.  Table 3 shows the result. 


We  develop  Z-Channel,  a  micropayment  channel  scheme  over  Zerocash. In  particular, we  improve  the  original  DAP scheme of Zerocash and propose DAP Plus, which supports  multisignature and time lock functionalities that are essential  in implementing micropayment channels. We then construct  the Z-Channel protocol, which allows numerous payments  conducted and confirmed off-chain in short periods of time.  The privacy protection provided by Z-Channel ensures that  the identities of the parties and the balances of the channels  and even the existence of the channel are kept secret. Finally,  we  implement  Z-Channel  protocol,  and  our  experiments  demonstrate that Z-Channel significantly improves the scal ability and reduces the average payment time of Zerocash. 
